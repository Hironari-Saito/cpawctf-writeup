# Q21.[Reversing]reversing easy!
フラグを出す実行ファイルがあるのだが、プログラム(elfファイル)作成者が出力する関数を書き忘れてしまったらしい…


## Solution
[IDA-Freeware](https://hex-rays.com/ida-free)を利用して与えられたプログラムを確認する。

IDAを開いた段階で、`yakiniku!`っぽい文字列が見えるので、おそらくこれがFlagであろう。

とりあえずデバッグ内容を確認し、推測したコードを`reversing.c`として作成


## Another Solution
もう少しスマートな方法を考える。`gdb-peda`を利用して`i == 5`の部分の分岐を変更してプログラムに出力させることを目標とする。

この分岐している部分は`0x08048536`のようなので、ここにブレイクポイントを貼り、フラグを書き換える。
eflagsが`0x246`となっているので、`0x206`として`ZF`フラグを削除し処理を続ける。
```
$ gdb rev100
gdb-peda$ b *0x08048536
gdb-peda$ run 
gdb-peda$ i r
eax            0x5                 0x5
ecx            0xf7f9c000          0xf7f9c000
edx            0x6c0               0x6c0
ebx            0x0                 0x0
esp            0xffffcfe0          0xffffcfe0
ebp            0xffffd038          0xffffd038
esi            0x1                 0x1
edi            0x80483a0           0x80483a0
eip            0x8048536           0x8048536 <main+153>
eflags         0x246               [ PF ZF IF ]
cs             0x23                0x23
ss             0x2b                0x2b
ds             0x2b                0x2b
es             0x2b                0x2b
fs             0x0                 0x0
gs             0x63                0x63

gdb-peda$ set $eflags=0x206
gdb-peda$ i r
eax            0x5                 0x5
ecx            0xf7f9c000          0xf7f9c000
edx            0x6c0               0x6c0
ebx            0x0                 0x0
esp            0xffffcfe0          0xffffcfe0
ebp            0xffffd038          0xffffd038
esi            0x1                 0x1
edi            0x80483a0           0x80483a0
eip            0x8048536           0x8048536 <main+153>
eflags         0x206               [ PF IF ]
cs             0x23                0x23
ss             0x2b                0x2b
ds             0x2b                0x2b
es             0x2b                0x2b
fs             0x0                 0x0
gs             0x63                0x63
gdb-peda$ c
Continuing.
cpaw{yakiniku!}
[Inferior 1 (process 49688) exited normally]
Warning: not running
gdb-peda$
```
この方法でもFlagを取得できることが確認できた。

## Answer
cpaw{yakiniku!}


## Reference

### EFLAGSレジスタ (Wikiより)
32ビットレジスタで、操作の結果やプロセッサの状態の格納と制御のための判断材料として使用される。
ビットの名前が0または1になっているものは予約されているので、変更されるべきではない。 

| bit | 名前 |
| :-- | :-- |
| 0 | CF:　キャリーフラグ。最後の算術演算操作で加算においてレジスタの大きさを越えてビットのキャリー（桁上がり）かボロー（桁借り）をした場合にセットされる。これは、キャリーの生じた加算やボローの生じた減算の次の操作がされた場合に、1個のレジスタだけ扱うことのできる値であるか確認するのに使われる。 | 
| 1 | 1 |
| 2 | PF: パリティフラグ。結果の最下位バイトに値1 のビットが偶数個含まれている場合にセットされ、奇数個の場合にはクリアされる。 |
| 3 | 0 |
| 4 | AF: 調整フラグ。2進化10進 (BCD) 演算の算術演算でキャリーまたはボローが生じたらセットされる。 |
| 5 | 0 |
| 6 | ZF : ゼロフラグ。操作の結果がゼロ (0) になった場合にセットされる。 |
| 7 | SF : 符号フラグ。操作の結果が負となった場合にセットされる。|
| 8 | TF : トラップフラグ。ステップバイステップのデバッギングをする場合にセットする。|
| 9 | IF : 割り込み可能フラグ。割り込みを有効化したい場合にセットする。|
| 10 | DF : 方向フラグ。ストリームの方向を制御する。セットするとストリング命令においてポインタがデクリメントされる（通常はインクリメントされる）。 |
| 11 | OF : オーバーフローフラグ。符号付き算術演算の結果がレジスタに格納できないほど大きい値になった場合にセットされる。 |
| 12 - 13 | IOPL : I/O特権レベルフィールド（2ビット）。現在のプロセスのI/O特権レベルを示す。 |
| 14 | NT : ネストタスクフラグ。割り込みチェーンを制御する。現在のプロセスが次のプロセスにリンクされている場合にセットされる。 |
| 15 | 0 |
| 16 | RF : 再開フラグ。デバッグ例外への応答を制御する。 |
| 17 | VM : 仮想8086モード。8086互換モードにある場合にセットされる。 |
| 18 | AC : アラインメントチェックフラグ。メモリチェックでアラインメントチェックが有効な場合にセットされる。 |
| 19 | VIF : 仮想割り込みフラグ。IFの仮想イメージ。 |
| 20 | VIP : 仮想割り込み保留フラグ。割り込みが保留されている場合にセットされる。 |
| 21 | ID : 識別フラグ。セットできればCPUID命令がサポートされる。 |
| 22 | 0 |
| 23 | 0 |
| 24 | 0 |
| 25 | 0 |
| 26 | 0 |
| 27 | 0 |
| 28 | 0 |
| 29 | 0 |
| 30 | 0 |
| 31 | 0 |
